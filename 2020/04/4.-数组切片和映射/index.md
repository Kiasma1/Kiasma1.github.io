# 4.数组、切片和映射


Go 语言有 3 种数据结构可以让用户管理集合数据：数组、切片和映射。

了解这些数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。

<!--more-->

# Ch04 数组、切片和映射

## 数组的内部实现和基础功能

了解这些数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。理解了数
组的工作原理，有助于理解切片和映射提供的优雅和强大的功能。

### 4.1.1 内部实现

在 Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连
续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。

![](http://cdn.shanzei.top/20200410145415.png)

### 4.1.2 声明和初始化

```go
var array [5]int
```

一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素，就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。

在 Go 语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。当数组初始化时，数组内每个元素都初始化为对应类型的零值。

```go
array := [5]int{10, 20, 30, 40, 50}
array := [...]int{10, 20, 30, 40, 50}
array := [5]int{1:10, 2:20}
```

### 4.1.3 使用数组

```go
array := [5]int{10, 20, 30, 40, 50}
array[2] = 35
```

![](http://cdn.shanzei.top/20200410151641.png)

```go
array := [5]*int{0: new(int), 1: new(int)}
*array[0] = 10
*array[1] = 20
```

![](http://cdn.shanzei.top/20200410151705.png)

```go
array1 := [5]string{"Red", "Blue", "Green", "Yellow", "Pink"}
array2 := array1
//长度和元素类型相同的数组才能相互赋值，赋值后是一个新的拷贝
```

![](http://cdn.shanzei.top/20200410151808.png)

```go
array1 := [3]*string{new(string), new(string), new(string)}

var array2 [3]*string
array2 = array1
//或者合并为一句 array2 := array1

*array1[0] = "Red"
*array1[1] = "Blue"
*array1[2] = "Green"
```

![](http://cdn.shanzei.top/20200410152109.png)

### 4.1.4 多维数组

{% raw %}
```go
var array [4][2]int

array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

array := [4][2]int{1: {20, 21}, 3: {40, 41}}

array := [4][2]int{1: {0: 20}, 3: {1: 41}}
```
{% endraw %}

![](http://cdn.shanzei.top/20200410153600.png)

### 4.1.5 在函数间传递数组

```go
var array [1e6]int

//按值传递, 在栈上分配 8 MB 的内存
func foo(array [1e6]int){ ... }
foo(array)

//按指针传递, 在栈上分配 8 字节的内存给指针
func foo(array *[1e6]int){ ... }
foo(&array)
```

## 4.2 切片的内部实现和基础功能

切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。

### 4.2.1 内部实现

这 3 个字段分别是**指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）**。后面会进一步讲解长度和容量的区别。

![](http://cdn.shanzei.top/20200410160534.png)

### 4.2.2 创建和初始化

1. make和切片字面量

```go
//make
slice := make([]string, 5) //长度和容量都是5
slice := make([]string, 3, 5) //长度为3 容量为5
//不允许创建容量小于长度的切片
```

```go
//字面量
slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}
//长度和容量都是 5 个元素
slice := []int{10, 20, 30}
//长度和容量都是 3 个元素
```

2. nil和空切片

```go
//声明nil整型切片
var slice []int
```

![](http://cdn.shanzei.top/20200410170934.png)

```go
//声明空切片
slice := make([]int, 0)
slice := []int{}
```

### 4.2.3 使用切片

1. 赋值和切片

```go
slice := []int{10, 20, 30, 40, 50}
slice[1] = 25
```

```go
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
```

![](http://cdn.shanzei.top/20200410171359.png)

![](http://cdn.shanzei.top/20200410171514.png)

切片的切片和原来的切片共用底层数组

![](http://cdn.shanzei.top/20200410171631.png)

2. 切片增长

当append 调用返回时，会返回一个包含修改结果的新切片。函数 append 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。

**如果容量不变则前后切片共享底层数组，如果容量改变则会新建底层数组**

```go
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice = append(newSlice, 60)
```

![](http://cdn.shanzei.top/20200410172801.png)

```go
slice := []int{10, 20, 30, 40}
newSlice := append(slice, 50)
```

![](http://cdn.shanzei.top/20200410173853.png)



函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%容量。随着语言的演化，这种增长算法可能会有所改变。
