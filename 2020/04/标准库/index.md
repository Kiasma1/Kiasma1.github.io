# 8. 标准库


Go 标准库是一组核心包，用来扩展和增强语言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写自己的包或者去下载其他人发布的第三方包。

<!--more-->

# Ch08 标准库

## 8.1 文档与源代码

Go语言团队在网站上维护了一个文档，参见 http://golang.org/pkg/。golang 网站的 pkg 页面提供了每个包的 godoc 文档。

作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作**归档文件**（archive file），可以 在 `$GOROOT/pkg  文件夹中找到已经安装的各目标平台和操作系统的归档文件。可以看到扩展名是.a 的文件，这些就是归档文件。

Go 工具链知道什么时候可以使用已有的.a 文件，什么时候需要从机器上的源代码重新构建。

## 8.2 记录日记

在 UNIX 里，日志有很长的历史。这些积累下来的经验都体现在 log 包的设计里。传统的CLI（命令行界面）程序直接将输出写到名为 `stdout` 的设备上。所有的操作系统上都有这种设备，这种设备的默认目的地是标准文本输出。默认设置下，终端会显示这些写到 `stdout` 设备上的文本。这种单个目的地的输出用起来很方便，不过你总会碰到需要同时输出程序信息和输出执行细节的情况。这些执行细节被称作日志。当想要记录日志时，你希望能写到不同的目的地，这样就不会将程序的输出和日志混在一起了。

为了解决这个问题，UNIX 架构上增加了一个叫作 `stderr` 的设备。这个设备被创建为日志的默认目的地。这样开发人员就能将程序的输出和日志分离开来。如果想在程序运行时同时看到程序输出和日志，可以将终端配置为同时显示写到 `stdout` 和 `stderr` 的信息。不过，如果用户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到 `stdout`，将错误或者警告信息写到 `stderr`。

### 8.2.1 log包

```
//跟踪日志的样例
TRACE: 2009/11/10 23:00:00.000000 /tmpfs/gosandbox-/prog.go:14: message
```

可以看到一个由 log 包产生的日志项。这个日志项包含前缀、日期时间戳、该日志具体是由哪个源文件记录的、源文件记录日志所在行，最后是日志消息。让我们看一下如何配置 log 包来输出这样的日志项

```go
package main

import "log"

func init() {
    log.SetPrefix("TRACE: ")
    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
}

func main() {
    // Println 写到标准日志记录器
    log.Println("message")

    // Fatalln 在调用 Println()之后会接着调用 os.Exit(1)
    log.Fatalln("fatal message")

    // Panicln 在调用 Println()之后会接着调用 panic()
    log.Panicln("panic message")
}
```

通常程序会在这个 `init()` 函数里配置日志参数，这样程序一开始就能使用 log 包进行正确的输出。在这段程序的第 6 行，设置了一个字符串，作为每个日志项的前缀。这个字符串应该是能让用户从一般的程序输出中分辨出日志的字符串。传统上这个字符串的字符会全部大写。

有几个和 log 包相关联的标志，这些标志用来控制可以写到每个日志项的其他信息。代码

```go
//展示了目前包含的所有标志。
const (
    // 将下面的位使用或运算符连接在一起，可以控制要输出的信息。没有
    // 办法控制这些信息出现的顺序（下面会给出顺序）或者打印的格式
    // （格式在注释里描述）。这些项后面会有一个冒号：
    // 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    // 日期: 2009/01/23
    Ldate = 1 << iota
    // 时间: 01:23:23
    Ltime
    // 毫秒级时间: 01:23:23.123123。该设置会覆盖 Ltime 标志
    Lmicroseconds
    // 完整路径的文件名和行号: /a/b/c/d.go:23
    Llongfile
    // 最终的文件名元素和行号: d.go:23
    // 覆盖 Llongfile
    Lshortfile
    // 标准日志记录器的初始值
    LstdFlags = Ldate | Ltime
)
```

这里的 `Ldate` 使用的是一种特殊的语法来声明的。

```go
Ldate = 1 << iota
```

关键字 `iota` 在常量声明区里有特殊的作用。这个关键字让编译器为每个常量复制相同的表达式，直到声明区结束，或者遇到一个新的赋值语句。关键字 `iota` 的另一个功能是，`iota` 的初始值为 0，之后 `iota` 的值在每次处理为常量后，都会自增 1。

```go
const (
Ldate = 1 << iota // 1 << 0 = 000000001 = 1
Ltime // 1 << 1 = 000000010 = 2
Lmicroseconds // 1 << 2 = 000000100 = 4
Llongfile // 1 << 3 = 000001000 = 8
Lshortfile // 1 << 4 = 000010000 = 16
...
)
```

操作符<<对左边的操作数执行按位左移操作。在每个常量声明时，都将 1 按位左移 iota 个位置。最终的效果使为每个常量赋予一个独立位置的位，这正好是标志希望的工作方式。

这里 `LstdFlags` 的赋值打破了 `iota` 常数链，而且我们可以得出该常量的值是`000000011` 即`Ldate`和`Ltime`标志位都被标一,即将`Ldate`和`Ltime`一起输出。

如何使用 3 个函数 `Println`、`Fatalln` 和 `Panicln` 来写日志消息。这些函数也有可以格式化消息的版本，只需要用 f 替换结尾的 ln。`Fatal` 系列函数用来写日志消息，然后使用 `os.Exit(1)` 终止程序。`Panic` 系列函数用来写日志消息，然后触发一个 `panic`。除非程序执行 `recover` 函数，否则会导致程序打印调用栈后终止。`Print` 系列函数是写日志消息的标准方法。

log 包有一个很方便的地方就是，这些日志记录器是多 `goroutine` 安全的。这意味着在多个 `goroutine` 可以同时调用来自同一个日志记录器的这些函数，而不 会有彼此间的写冲突。标准日志记录器具有这一性质，用户定制的日志记录器也应该满足这一性质。

### 8.2.2 定制的日志记录器

要想创建一个定制的日志记录器，需要创建一个 Logger 类型值。可以给每个日志记录器配置一个单独的目的地，并独立设置其前缀和标志。

```go

```
