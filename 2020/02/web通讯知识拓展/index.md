# Web通讯知识拓展


Web通讯知识拓展
<!--more-->

# 基础拓展

## FTP

**文件传输协议**（**F**ile **T**ransfer **P**rotocol, FTP）是一个用于再计算机网络上在客户端和服务器之间进行文件传输的**应用层协议**。
FTP是一个8位的客户端-服务器协议，能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。
但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。

FTP服务一般运行在20和21两个端口。端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流，并且是命令通向ftp服务器的进口。当数据通过数据流传输时，控制流处于空闲状态。而当控制流空闲很长时间后，客户端的防火墙会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功的传输，但因为控制会话，会被防火墙断开；传输会产生一些错误。

FTP虽然可以被终端用户直接使用，但是它是设计成被FTP客户端程序所控制。
运行FTP服务的许多站点都开放匿名服务，在这种设置下，用户不需要帐号就可以登录服务器，默认情况下，匿名用户的用户名是：“anonymous”。

##FTP实现的目标：##

- 促进文件的共享（计算机程序或数据）Gnome-fs-ftp.png
- 鼓励间接或者隐式的使用远程计算机
- 向用户屏蔽不同主机中各种文件存储系统（File system）的细节
- 可靠和高效的传输数据

主动和被动模式
FTP有两种使用模式：主动和被动。主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。

##一个主动模式的FTP连接创建要遵循以下步骤：##

1. 客户端打开一个随机的端口（端口号大于1024，在这里，我们称它为x），同时一个FTP进程连接至服务器的21号命令端口。此时，该tcp连接的来源地端口为客户端指定的随机端口x，目的地端口（远程端口）为服务器上的21号端口。
2. 客户端开始监听端口（x+1），同时向服务器发送一个端口命令（通过服务器的21号命令端口），此命令告诉服务器客户端正在监听的端口号并且已准备好从此端口接收数据。这个端口就是我们所知的数据端口。
3. 服务器打开20号源端口并且创建和客户端数据端口的连接。此时，来源地的端口为20，远程数据(目的地)端口为（x+1）。
4. 客户端通过本地的数据端口创建一个和服务器20号端口的连接，然后向服务器发送一个应答，告诉服务器它已经创建好了一个连接。

## HTTP
超文本传输协议（**H**yper**T**ext **T**ransfer **P**rotocol）是一种应用层协议

**设计HTTP最初的目的**是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识

HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

尽管TCP/IP协议是互联网上最流行的应用，但是在HTTP协议中并没有规定它必须使用或它支持的层。事实上HTTP可以在任何互联网协议或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用，所以其在TCP/IP协议族使用TCP作为其传输层。

通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

### 请求方法

#### GET
向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中。

#### HEAD
与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

#### POST
向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

#### PUT
从客户端向服务器传送的数据取代指定文档的内容

#### DELETE
请求服务器删除Request-URI所标识的资源。

#### TRACE
回显服务器收到的请求，主要用于测试或诊断。

#### OPTIONS
这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

#### CONNECT
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。

方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。

### 状态码
1xx消息——请求已被服务器接收，继续处理

2xx成功——请求已成功被服务器接收、理解、并接受

3xx重定向——需要后续操作才能完成这一请求

4xx请求错误——请求含有词法错误或者无法被执行

5xx服务器错误——服务器在处理某个正确请求时发生错误

## FILE
file协议（本地文件传输协议）主要是用来访问本地计算机的文件，一般用Windows的资源管理器直接打开进行读取一个HTML文件时，默认会使用file协议。

## Request Header
### User-Agent ###
User Agent（用户代理、UA），它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。
### Host ###
请求的主机名，允许多个域名同处一个ip地址，即虚拟主机。
能够很好的解决一个ip地址对应多个域名的问题。
当服务器接收到来自浏览器的请求时，会根据请求头中的host字段访问哪个站点。
### Cookie ###
Cookie是用于维持服务端会话状态的，通常由服务端写入，在后续请求中，供服务端读取。
![](https://raw.githubusercontent.com/Kiasma1/Kiasma1.github.io/master/posts/2019/20191001175254.png)
HTTP请求，Cookie的使用过程
1. server通过HTTP Response中的"Set-Cookie: header"把cookie发送给client
2. client把cookie通过HTTP Request 中的“Cookie: header”发送给server
3. 每次HTTP请求，Cookie都会被发送。

http请求发送cookies的条件：

1. 本地已经缓存有cookies
2. 根据请求的URL来匹配cookies的domain、path属性，如果都符合才会发送。
举个例子：访问www.baidu.com时，就不发送www.qq.com的cookies.
### The X-Frame-Options ###
The X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在` <frame>, <iframe>, <embed> 或者 <object> `中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 clickjacking 攻击。

X-Frame-Options 有三个可能的值：
```
X-Frame-Options: deny
X-Frame-Options: sameorigin
X-Frame-Options: allow-from https://example.com/
```
- deny
表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
- sameorigin
表示该页面可以在相同域名页面的 frame 中展示。
- allow-from uri
表示该页面可以在指定来源的 frame 中展示。

## Response Header
### Server ###
Server 首部包含了处理请求的源头服务器所用到的软件相关信息。处理请求的软件或者产品（或组件产品）的名称。
### Set-Cookie ###
响应首部 Set-Cookie 被用来由服务器端向客户端发送 cookie。
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie
### Content-Type ###
Content-Type 实体头部用于指示资源的MIME类型 media type 。

在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。

在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。

`media-type`资源或数据的 MIME type 。
`charset`字符编码标准。

#### MIME type ####
（现在称为“媒体类型(media type)”，但有时也是“内容类型(content type)”）是指示文件类型的字符串，与文件一起发送（例如，一个声音文件可能被标记为 audio/ogg ，一个图像文件可能是 image/png ）。它与传统Windows上的文件扩展名有相同目的。

### HttpOnly ###
如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，

## Base64编码 ##
https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576

## HTTP基本认证 ##
https://blog.csdn.net/wochunyang/article/details/78675325

## HTTP与HTTPS ##
https://blog.csdn.net/whatday/article/details/38147103
