# C详解 数的表示


C详解 数的表示

<!--more-->

## 加减法

计算机要对这样的两个数做加法运算需要处理以下逻辑：

- 如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，则结果超出7位所能表示的数值范围，这称为溢出（Overflow），通常把计算机中的一个标志位置1表示产生溢出。

- 如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同。

减法运算需要处理以下逻辑：

- 如果两数符号位相同，并且低7位是大数减小数，则符号位不变，如果低7位是小数减大数，则按大数减小数计算，结果要变号。

- 如果两数符号位不同，把低7位相加，如果是正数减负数则结果为正，如果是负数减正数则结果为负，低7位在相加时可能产生溢出。

这其实是和手算加减法的逻辑是相同的。

算加减法需要处理这么多的逻辑：比较符号位，比较绝对值，加法改减法，减法改加法...这是**非常低效率**的。还有就是**0的表示不唯一**

有一种方法可以把减法全部转化成加法来计算：简单来说就是减去一个数等于加上这个数取9的补码（9's Complement）再加1（忽略最高位的进位）

**类推到二进制加减法就是：减去一个数等于加上这个数取1的补码（1's Complement 又被称为反码）再加1（忽略最高位的进位）**

采用补码做加减运算时总是忽略MSB的进位，这让人很不放心：如果在计算过程中忽略进位的效果没有相互抵消怎么办？如果没有相互抵消，最后的结果肯定是错的，这种情况一定是由溢出引起的。只要我们有办法判断哪些情况会产生溢出，其它情况下都可以放心地忽略MSB的进位。判断溢出的办法是这样的：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，否则就说明产生了溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。

### ## 浮点数

http://docs.linuxtone.org/ebooks/C&CPP/c/ch14s04.html
